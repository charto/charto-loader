'use strict';

/** SystemJS API. */
var System;

/** Loader API. */
var charto = charto || {};

/** Initialize SystemJS.
  *
  * @param { Object | string | string[] } config - SystemJS configuration
  *   object or config file address / addresses.
  * @param { function } done - Called after SystemJS is initialized.
  * @param { Object } firstConfig - Optional initial SystemJS config object. */

charto.initSystem = function(config, done, firstConfig) {
	var configType = typeof(config);
	var configURL;

	if(configType == 'function') {
		// Handle omitted config argument.
		done = config;
		config = {};
	} else if(configType != 'object' || !config) {
		// Handle null config or external file address(es).
		configURL = config;
		config = {};
	}

	// Always configure at least a base URL matching the current page
	// location, unless specified otherwise.

	firstConfig = firstConfig || {};
	firstConfig.baseURL = (
		firstConfig.baseURL ||
		config.baseURL ||
		self.location.pathname.replace(/\/[^/]+$/, '/')
	);

	// Avoid errors from setting baseURL after other options were given.
	delete config.baseURL;

	/** Default path mappings for required loader modules. */

	var paths = {
		corejs: [
			'node_modules/core-js-bundle/minified.js',
			'https://unpkg.com/core-js@2/client/shim.min.js'
		],
		systemjs: [
			'node_modules/systemjs/dist/system.js',
			'https://unpkg.com/systemjs@0.21/dist/system.js'
		],
		config: configURL
	};

	/** List of loader dependencies (fetched asynchronously, executed
	  * synchronously). */

	var deps = [
		// 1. Load core-js if native Promise support is missing.
		typeof(Promise) != 'function' && 'corejs',

		// 2. Always load SystemJS. A future browser implementation may
		// be incompatible with our Node.js module resolution patches.
		'systemjs',

		// 3. Patch SystemJS to support Node.js module resolution.
		charto.patchSystem,

		// 4. Apply SystemJS configuration objects before loading files.
		function() {
			System.config(firstConfig);
			System.config(config);
		},

		// 5. Load external SystemJS configuration file
		// (from address or list of possible addresses).
		configURL && 'config',

		// 6. Call done at the end.
		done
	];

	// Try to load dependencies, first according to path mappings
	// from SystemJS config, then call done (see above).

	charto.require(deps, paths, config.map || {});
};

/** Initialize SystemJS with TypeScript transpiler.
  *
  * @param { Object | string | string[] } config - SystemJS configuration
  *   object or config file address / addresses.
  * @param { function } done - Called after SystemJS is initialized. */

charto.initSystemTS = function(config, done) {
	charto.initSystem(config, done, {
		transpiler: 'plugin-typescript',

		packages: {
			'dist/': {
				defaultExtension: 'js'
			},
			'src/': {
				defaultExtension: 'ts'
			}
		},

		meta: {
			'*.vert': { loader: 'systemjs-plugin-text' },
			'*.frag': { loader: 'systemjs-plugin-text' },
			'*.css': { loader: 'charto-plugin-css' }
		},

		// Support JSX, transpiling HTML to function calls.

		typescriptOptions: {
			jsx: 'react'
		}
	});
};

/** Patch SystemJS to support Node.js module resolution.
  *
  * @param { Object } System - SystemJS object to patch.
  * @param { function } done - Called after patch is loaded and applied. */

charto.patchSystem = function(sys) {
	// Builder injects a SystemJS-format bundle here,
	// containing a library for handling Node.js module resolution:

	/* cresolve */

	// Initialize the library.
	return(System.import('cresolve').then(function(pkg) {
		charto.resolver = new pkg.Resolver(
			pkg.ifExists,
			pkg.fetch,
			charto.resolverConfig
		).patchSystem(sys || System);

		// Expose the resolver's autogenerated SystemJS config object directly
		// through this loader.

		charto.systemConfig = charto.resolver.systemConfig;

		// If inside a Web Worker and the initial message contained a message
		// channel port, pass it to the resolver for communication with the
		// UI thread.

		if(charto.resolverPort) charto.resolver.setPort(charto.resolverPort);
	}));
};

/** Cache for addresses where modules were found (after redirections) */
charto.requireCache = {};

/** Simple script loader supporting multiple alternative locations,
  * for fetching better loaders. Errors in setting up a loader are likely
  * unrecoverable, so they get thrown asynchronously and cannot be caught.
  * A success callback function can be added at the end of the deps array.
  *
  * @param { (string | function)[] } deps - Functions (optionally returning
  *   promises) to run or names of modules to load (in order).
  * @param { object } paths - Mapping of module names to URLs or
  *   arrays of several alternative URLs.
  * @param { Object } guess - Mapping of module names to URLs,
  *   tried before paths. */

charto.require = function(deps, paths, guess) {
	var ss = typeof(window) == 'object' && window.sessionStorage;
	var cache = charto.requireCache;
	/** Modules ready for execution, in same order as deps. */
	var scripts = [];
	/** Number of modules fetched so far. */
	var fetched = 0;

	/** Try to load a single module from multiple possible addresses.
	  *
	  * @param { number } num - Index of module in deps to maintain order.
	  * @param { string } key - Key for successfully resolved address cache.
	  * @param { string[] } urls - Addresses in order of decreasing preference. */

	function exec() {
		var result;

		while(scripts.length) {
			var script = scripts.shift();
			if(typeof(script) == 'function') {
				result = script();
				if(result && typeof(result) == 'object' && typeof(result.then) == 'function') {
					result.then(exec);
					break;
				}
			} else {
				eval(script);
			}
		}
	}

	function load(num, key, urls) {
		var retried = false;
		var uri = urls.shift();

		function retry(err) {
			if(retried) return;
			retried = true;

			if(!urls.length) throw(err);
			load(num, key, urls);
		}

		var xhr = new XMLHttpRequest();

		xhr.onerror = retry;
		xhr.onload = function() {
			if(xhr.readyState != 4) return;
			if(xhr.status != 200) return(retry(xhr.status));

			// Cache successfully resolved addresses.
			// This has redirections already applied.
			cache[key] = xhr.responseURL || uri;
			if(ss) ss.setItem(key, cache[key]);

			// Store module code for execution in correct order.
			scripts[num] = xhr.responseText;

			if(++fetched >= deps.length) {
				// After all modules are loaded, execute them in the same
				// order as listed in deps.

				exec();
			}
		};

		xhr.open('GET', uri, true);
		xhr.send();
	}

	for(var num = 0; num < deps.length; ++num) {
		var mod = deps[num];

		if(typeof(mod) == 'string') {
			// Resolve modules according to paths and try to load from
			// all possible addresses given.

			var urls = paths[mod];
			var key = 'charto/resolve/' + mod;
			var found = cache[key] || (ss && ss.getItem(key)) || guess[mod];

			if(typeof(urls) == 'string') urls = [ urls ];
			if(found) urls.unshift(found);

			load(num, key, urls);
		} else {
			// Queue already defined code for execution in order.

			scripts[num] = mod || function(){};
			++fetched;
		}
	}
};

// Autodetect address of this script, for passing as an entry point to new
// Web Workers.

if(typeof(document) == 'object' && typeof(document.currentScript) == 'object') {
	charto.loaderPath = document.currentScript.src;
} else {
	// For IE, throw an error to get the script address from its stack trace.

	(function() {
		try {
			throw(new Error());
		} catch(err) {
			// proto colon slashes domain (no slashes) slash path (no colons)
			var match = err.stack.match(/[A-Za-z]+:\/+[^/ \t\n]*\/[^: \t\n]+/);
			if(match) charto.loaderPath = match[0];
		}
	})();
}

/** Create a Web Worker with Node.js module loading support.
  *
  * @param { string } uri - Worker entry point address.
  *   Resolved, fetched and transpiled as needed.
  * @return { Object } Object with fields:
  * - worker: the native Web Worker object.
  * - ready: promise resolving to the worker, after all code in entry point
  *   script was executed. */

charto.createWorker = function(uri) {
	/** Created Web Worker running this script. */
	var worker = new Worker(charto.loaderPath);

	/** Promise resolving when app entry point is loaded. */
	var ready = new Promise(function(resolve, reject) {
		/** Initial message to configure this loader inside a Web Worker,
		  * sent through the default channel. */
		var msg = {
			// Address of app entry point script.
			uri: uri,
			// Full SystemJS config.
			config: System.getConfig(),
			// Autogenerated parts of the config.
			generated: charto.systemConfig,
			// Resolved module address cache.
			cache: charto.requireCache
		};

		/** Dedicated message channel for loader-specific communication,
		  * to avoid disrupting the main app's internal messaging. */
		var remote = (
			typeof(MessageChannel) == 'function' &&
			charto.resolver.createPort(System, resolve, reject, worker)
		);

		if(remote) {
			// Send initial message to this loader running inside the worker,
			// passing ownership of the dedicated message channel remote port.

			msg.port = remote;
			worker.postMessage(msg, [ remote ]);
		} else {
			worker.postMessage(msg);
			// TODO: Can we even have Worker without MessageChannel?
			// This promise should resolve only when the worker entry point was executed...
			resolve(worker);
		}
	});

	return({ ready: ready, worker: worker });
};

if(
	typeof(WorkerGlobalScope) != 'undefined' &&
	self instanceof WorkerGlobalScope &&
	typeof(onmessage) != 'function'
) {
	// Running inside a Web Worker.
	// Handle initial message, containing app entry point address
	// and message port for further communication with the UI thread.

	charto.onmessage = function(event) {
		var queue = charto.messageQueue;

		// Queue further messages to avoid losing them.
		if(queue) return(queue.push(event));

		var uri = event.data.uri;
		var init = charto.initSystem;

		queue = [];
		charto.messageQueue = queue;

		// Set up transpiler when importing .ts files.

		if(uri.match(/\.ts$/i)) init = charto.initSystemTS;

		charto.resolverPort = event.data.port;
		charto.resolverConfig = event.data.generated;
		charto.requireCache = event.data.cache || {};

		init(event.data.config || {}, function() {
			// Fetch and execute app entry point.

			System.import(uri).then(function() {
				// Report success to resolve promise from UI thread createWorker.

				charto.resolver.reportLoad(true);

				if(queue.length && typeof(onmessage) == 'function' && onmessage != charto.onmessage) {
					// If there are queued messages and the imported code defined
					// a handler, process and then discard the queue.

					for(var num = 0; num < queue.length; ++num) {
						onmessage(queue[num]);
					}

					queue = void 0;
					charto.messageQueue = queue;
				}
			}).catch(function(err) {
				// Report failure to reject promise from UI thread createWorker.
				// Throw the error to show it in debug console.

				charto.resolver.reportLoad(false);
				throw(err.originalErr || err);
			});
		});
	};

	// Start handling messages to avoid losing any.
	onmessage = charto.onmessage;
}
